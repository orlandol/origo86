

                   Origo86 Language Specification
                   Copyright 2018 Orlando Llanes


                        Table of Contents

                        1) Introduction
                        2) Symbol Glossary
                        3) Program Structure
                        4) Module Structure
                        5) Type Specification
                        6) General Declarations
                        7) Object Declarations
                        8) Method Declarations
                        9) Function Declarations
                       10) Operator Declarations
                       11) Expression Operators by Precedence
                       12) General Statements
                       13) Conditional Statements
                       14) Loop Statements
                       15) Assembler Statements
                       16) x86 16-Bit ModR/M Format
                       17) x86 Condition Test Encoding
                       18) x86 Instruction Encodings for x86GenXYZ
                                      --

                          1) Introduction

  The purpose of this document is to define the syntax structure of
    Origo86; similar in concept to an informal grammar specification.

  Retineo is Latin for steadfast. Origo is Latin for origin.

  Retineo is a general programming language designed to provide
    a stable foundation for low level, and cross-platform,
    software development.

  Low level syntax across platforms share a common structure,
    adapting unique platform specific constructs where needed.

  High level syntax allows the developer to declare a common interface
    once, while hiding platform specifics in the implementation.

  Retineo's syntax began with a Pascal, Basic, and C++ influence.
    Its syntax evolved to be simple and unambiguous, allowing the
    developer to maintain their stream of consciousness.

  Retineo's launch occurs in three phases:
    A) Origo86 - One-time x86 assembler implementation, to launch Origo.
    B) Origo - Self-compiling subset, to launch Retineo.
    C) Retineo - Self-compiling, full language implementation, of Retineo.

  This specification will likely change until Origo86 is complete.
                                      --

                         2) Symbol Reference

  2A) X => Y

    X becomes Y. Used to indicate how it will be referred to.

  2B) [ ]

    Everything enclosed within the brackets is optional. Brackets
    may be nested.

  2C) < | >

    Only one of the specified keywords/syntax applies per use.

  2D) ' '

    Syntax used as-is in source code text.
    Differentiates between convention symbol, and actual source code text.

  2E) ...

    Represents that preceding syntax may be repeated.
                                      --

                        3) Program Structure

  // Single line comment

  /* Multi-line
    /* and nested multi-line */
    comments */

  program IDENT => PROGNAME

  [uses MODNAME['(' FILENAME ')'][',' ...]]

  [DECLARATION]
  [...]

  run
    [var
      [TYPESPEC IDENT[','...]]
      [...]
    end]

    [STATEMENT]
    [...]
  end

  [DECLARATION]
  [...]
                                      --

                            4) Module Structure

  // Single line comment

  /* Multi-line
    /* and nested multi-line */
    comments */

  module IDENT => MODNAME

  [uses MODNAME['(' FILENAME ')'][',' ...]]

  [DECLARATION]
  [...]

  implementation

  [uses MODNAME['(' FILENAME ')'][',' ...]]

  [DECLARATION]
  [...]

  init
    [var
      [TYPESPEC IDENT[','...]]
      [...]
    end]

    [STATEMENT]
    [...]
  end

  done
    [var
      [TYPESPEC IDENT[','...]]
      [...]
    end]

    [STATEMENT]
    [...]
  end

  [DECLARATION]
  [...]
                                      --

                        5) Type Specification

  BASETYPE = < uint | uint8 | uint16 | int | int8 | int16 |
               bool | char  | string >
             
  SIMPLETYPE = < BASETYPE | TYPENAME | STRUCTNAME | UNIONNAME |
                 OBJNAME['('IFCNAME[','...]')'] |
                 ABSNAME['('IFCNAME[','...]')'] >

  TYPESPEC = ['@']SIMPLETYPE[ '[' CONSTEXPR['..'CONSTEXPR][','...] ']' ]

    '@' specifies that the type is a pointer.
    Array indices can consist of either a range, or a count value.
                                      --

                            6) General Declarations

  type TYPESPEC IDENT[','...] ['=' CONSTEXPR] => TYPENAME

  alias TYPENAME IDENT => TYPENAME

  enum [BASETYPE] IDENT => ENUMNAME
    [group CONSTEXPR]
      [IDENT[','...] '=' CONSTEXPR] => ENUMVALUE
      [...]
    [...]
  end

  const [TYPESPEC] IDENT[','...] '=' < CONSTEXPR | INITIALIZER >

  struct IDENT => STRUCTNAME
    [TYPESPEC IDENT[','...]] => FIELDNAME
    [...]
  end

  union IDENT => STRUCTNAME
    [TYPESPEC IDENT[','...]] => FIELDNAME
    [...]
  end

  var
    [TYPESPEC IDENT[','...]['=' CONSTEXPR]] => GLOBALVAR
    [...]
  end

  funcdecl [TYPESPEC] IDENT '(' [PARAMDECL] ')'
    [link MANGLEDNAME from < OBJFILENAME | LIBFILENAME >
      [using CALLCONVENTION]]

  vardecl TYPESPEC IDENT
    [link MANGLEDNAME from < OBJFILENAME | LIBFILENAME >]
                                      --

                        7) Object Declarations

  object IDENT => OBJNAME [inherits OBJNAME[','...]]
  [ < public | visible | internal > ]
    [TYPESPEC IDENT[','...]] => MBRNAME
    [...]
  [...]
  end

  interface IDENT => IFCNAME
    [implements OBJNAME[','...]]
    [inherits IFCNAME[','...]]

    [method [TYPESPEC] [interrupt] IDENT] => MTHDNAME
    [...]
  end

  abstract IDENT => ABSNAME
    [implements OBJNAME[','...]]
    [inherits IFCNAME[','...]]

    [method [TYPESPEC] [interrupt] IDENT] => MTHDNAME
    [...]
  end

  private OBJNAME
    [TYPESPEC IDENT[','...]] => MBRNAME
    [...]
  end

  private IFCNAME
    [method [TYPESPEC] IDENT '(' [PARAMDECL] ')'] => MTHDNAME
    [...]
  end

  private ABSNAME
    [method [TYPESPEC] IDENT '(' [PARAMDECL] ')'] => MTHDNAME
    [...]
  end
                                      --

                        8) Method Declarations

  method [interrupt] OBJNAME'.'MTHDNAME '(' [PARAMDECL] ')'
    [var
      [TYPESPEC IDENT[','...]['=' CONSTEXPR]] => LOCALVAR
      [...]
    end]

    < [STATEMENT] | [return] >
    [...]
  end

  method TYPESPEC [interrupt] OBJNAME'.'MTHDNAME '(' [PARAMDECL] ')'
    [var
      [TYPESPEC IDENT[','...]['=' CONSTEXPR]] => LOCALVAR
      [...]
    end]

    < [STATEMENT] |
    [result ASSIGNOP EXPR] |
    [return [EXPR]] >
    [...]
  end

  method [TYPESPEC] asm [< noret | noframe >] [interrupt]
    OBJNAME'.'MTHDNAME '(' [PARAMDECL] ')'

    [var
      [TYPESPEC IDENT[','...]] => LOCALVAR
      [...]
    end]

    [ASMSTATEMENT]
    [...]
  end
                                      --

                        9) Function Declarations

  func [interrupt] IDENT '(' [PARAMDECL] ')' => FUNCNAME
    [var
      [TYPESPEC IDENT[','...]['=' CONSTEXPR]] => LOCALVAR
      [...]
    end]

    < [STATEMENT] | [return] >
    [...]
  end

  func TYPESPEC [interrupt] IDENT '(' [PARAMDECL] ')' => FUNCNAME
    [var
      [TYPESPEC IDENT[','...]['=' CONSTEXPR]] => LOCALVAR
      [...]
    end]

    < [STATEMENT] |
    [result ASSIGNOP EXPR] |
    [return [EXPR]] >
    [...]
  end

  func [TYPESPEC] asm [< noret | noframe >] [interrupt]
    IDENT '(' [PARAMDECL] ')' => FUNCNAME

    [var
      [TYPESPEC IDENT[','...]] => LOCALVAR
      [...]
    end]

    [ASMSTATEMENT]
    [...]
  end
                                      --

                       10) Operator Declarations

  operator TYPESPEC OP '(' TYPESPEC IDENT[','...] ')'
    < [STATEMENT] |
    [result ASSIGNOP EXPR] >
    [...]
  end

  cast TYPESPEC from TYPESPEC
    < [STATEMENT] |
    [result ASSIGNOP EXPR] >
    [...]
  end
                                      --

                       11) Expression Operators by Precedence

  VAROPERAND '++' => Post-Increment
  VAROPERAND '--' => Post Decrement

  '++' VAROPERAND => Pre-Increment
  '--' VAROPERAND => Pre-Decrement
  '-' OPERAND => Neg
  '!' OPERAND => Logical Not
  '~' OPERAND => Bitwise Complement

  OPERAND '*' OPERAND => Multiply
  OPERAND '/' OPERAND => Divide
  OPERAND '%' OPERAND => Modulus

  OPERAND '+' OPERAND => Add
  OPERAND '-' OPERAND => Sub

  OPERAND '<<' OPERAND => Shift-Left
  OPERAND '>>' OPERAND => Shift-Right
  OPERAND '->>' OPERAND => Signed Shift-Right
  OPERAND '<<<' OPERAND => Rotate Left
  OPERAND '<<<-' OPERAND => Signed Rotate Left
  OPERAND '>>>' OPERAND => Rotate Right
  OPERAND '->>>' OPERAND => Signed Rotate Right

  OPERAND '<' OPERAND => Less Than
  OPERAND '<=' OPERAND => Less Than or Equal To
  OPERAND '>' OPERAND => Greated Than
  OPERAND '>=' OPERAND => Greater Than or Equal To

  OPERAND '=' OPERAND => Equal To
  OPERAND '!=' OPERAND => Not Equal To

  OPERAND '&' OPERAND => Bitwise And

  OPERAND '^' OPERAND => Bitwise Exclusive Or

  OPERAND '|' OPERAND => Bitwise Or

  OPERAND '&&' OPERAND => Logical And

  OPERAND '||' OPERAND => Logical Or

  RESULT '=' EXPRESSION => Assign result from expression
  RESULT '+=' EXPRESSION => Add expression to the result
  RESULT '-=' EXPRESSION => Subtract expression from the result
  RESULT '*=' EXPRESSION => Multiply result by expression
  RESULT '/=' EXPRESSION => Divide result by expression
  RESULT '%=' EXPRESSION => Modulo result by expression
  RESULT '<<=' EXPRESSION => Shift result Left by expression
  RESULT '>>=' EXPRESSION => Shift result Right by expression
  RESULT '->>=' EXPRESSION => Signed Shift result Right by expression
  RESULT '<<<=' EXPRESSION => Rotate result Left by expression
  RESULT '<<<-=' EXPRESSION => Signed Rotate result Left by expression
  RESULT '>>>=' EXPRESSION => Rotate result Right by expression
  RESULT '->>>=' EXPRESSION => Signed Rotate result Right by expression
  RESULT '&=' EXPRESSION => Bitwise And result by expression
  RESULT '^=' EXPRESSION => Bitwise Xor result by expression
  RESULT '|=' EXPRESSION => Bitwise Or result by expression
                                      --

                       12) General Statements

  IDENT ':' => LABELNAME

  goto LABELNAME

  exit [CONSTEXPR]

  FUNCTIONCALL

  METHODCALL

  bind '(' OBJECTVAR ',' < IFCNAME | ABSNAME >[','...] ')'

  EXPRESSION
                                      --

                       13) Conditional Statements

  if CONDITION
    then STATEMENT

  if CONDITION
    [thenif CONDITION]
    [...]

    [STATEMENT]
    [...]
  [elseif CONDITION
    [thenif CONDITION]
    [...]

    [STATEMENT]
    [...]]
  [else
    [STATEMENT]
    [...]]
  endif

  [LABEL] case EXPR
    [precase
      < [STATEMENT] | [return] >
      [...]]
    [postcase
      < [STATEMENT] | [return] >
      [...]]
    [of CONSTEXPR['..' CONSTEXPR]
      < [STATEMENT] |
      [nextcase [LABEL] |
      [exitcase [LABEL] >
      [...]]
    [in '[' CONSTEXPR['..' CONSTEXPR][','...] ']'
      < [STATEMENT] |
      [nextcase [LABEL] |
      [exitcase [LABEL] >
      [...]]
    [default
      < [STATEMENT] |
      [nextcase [LABEL] |
      [exitcase [LABEL] >
      [...]]
  endcase
                                      --

                       14) Loop Statements

  [LABEL] while CONDITION
    < [STATEMENT] |
    [next [LABEL]] |
    [stop [LABEL]] >
    [...]
  endwhile

  [LABEL] repeat
    < [STATEMENT] |
    [next [LABEL]] |
    [stop [LABEL]] >
    [...]
  when CONDITION

  [LABEL] for IDENT in '[' EXPR['..' EXPR][','...] ']'
    < [STATEMENT] |
    [next [LABEL]] |
    [stop [LABEL]] >
    [...]
  endfor

  [LABEL] for IDENT '=' EXPR < to | downto > EXPR
    < [STATEMENT] |
    [next [LABEL]] |
    [stop [LABEL]] >
    [...]
  endfor

  STATEMENT [until CONDITION]
                                      --

                       15) x86 Assembler Instructions

  adc           jb            lodsw         rol           stosb
  add           jbe           loop          ror           stosw
  and           ja            loope         rep           sub
  call          jae           loopne        repe          test
  cbw           je            loopz         repne         xchg
  clc           jne           loopnz        repz          xlat
  cld           jz            mov           repnz         xlatb
  cli           jnz           movs          ret           xor
  cmc           jl            movsb         retf
  cmp           jle           movsw         sahf
  cmps          jg            mul           sal
  cmpsb         jge           neg           sar
  cmpsw         jc            nop           shl
  cwd           jnc           not           shr
  dec           jcxz          or            sbb
  div           jmp           out           scas
  idiv          lahf          pop           scasb
  imul          lds           popf          scasw
  in            les           push          stc
  inc           lea           pushf         std
  int           lods          rcl           sti
  iret          lodsb         rcr           stos
                                      --

                        16) x86 16-Bit ModR/M Format

  This section based on Table 2-1 16-Bit Addressing Forms with the ModR/M Byte
    from the Intel 64 and IA-32 Architectures Software Developer's Manual

  SS is the default segment register when BP is used as an index

  ModR/M = | 2-bit MOD | 3-bit REG | 3-bit RM ]

  ---------------------------------------------------------------------------
  Opcode extension encodings for /0 .. /7
  ---------------------------------------------------------------------------
  /0                  => MOD_000_RM
  /1                  => MOD_001_RM
  /2                  => MOD_010_RM
  /3                  => MOD_011_RM
  /4                  => MOD_100_RM
  /5                  => MOD_101_RM
  /6                  => MOD_110_RM
  /7                  => MOD_111_RM

  ---------------------------------------------------------------------------
  /r for 8-bit registers
  ---------------------------------------------------------------------------
  AL                  => MOD_000_RM
  CL                  => MOD_001_RM
  DL                  => MOD_010_RM
  BL                  => MOD_011_RM
  AH                  => MOD_100_RM
  CH                  => MOD_101_RM
  DH                  => MOD_110_RM
  BH                  => MOD_111_RM

  ---------------------------------------------------------------------------
  /r for 16-bit registers
  ---------------------------------------------------------------------------
  AX                  => MOD_000_RM
  CX                  => MOD_001_RM
  DX                  => MOD_010_RM
  BX                  => MOD_011_RM
  SP                  => MOD_100_RM
  BP                  => MOD_101_RM
  SI                  => MOD_110_RM
  DI                  => MOD_111_RM

  ---------------------------------------------------------------------------
  MOD 00
  ---------------------------------------------------------------------------
  [BX + SI]           => 00_REG_000
  [BX + DI]           => 00_REG_001
  [BP + SI]           => 00_REG_010
  [BP + DI]           => 00_REG_011
  [SI]                => 00_REG_100
  [DI]                => 00_REG_101
  DISP16              => 00_REG_110
  [BX]                => 00_REG_111

  - DISP16 is an index within the default, or specified, segment

  ---------------------------------------------------------------------------
  MOD 01
  ---------------------------------------------------------------------------
  [BX + SI] + DISP8   => 01_REG_000
  [BX + DI] + DISP8   => 01_REG_001
  [BP + SI] + DISP8   => 01_REG_010
  [BP + DI] + DISP8   => 01_REG_011
  [SI] + DISP8        => 01_REG_100
  [DI] + DISP8        => 01_REG_101
  [BP] + DISP8        => 01_REG_110
  [BX] + DISP8        => 01_REG_111

  - DISP8 is sign extended (for all of MOD 01?)

  ---------------------------------------------------------------------------
  MOD 10
  ---------------------------------------------------------------------------
  [BX + SI] + DISP16  => 10_REG_000
  [BX + DI] + DISP16  => 10_REG_001
  [BP + SI] + DISP16  => 10_REG_010
  [BP + DI] + DISP16  => 10_REG_011
  [SI] + DISP16       => 10_REG_100
  [DI] + DISP16       => 10_REG_101
  [BP] + DISP16       => 10_REG_110
  [BX] + DISP16       => 10_REG_111

  ---------------------------------------------------------------------------
  MOD 11 for 8-Bit Registers
  ---------------------------------------------------------------------------
  AL                  => 11_REG_000
  CL                  => 11_REG_001
  DL                  => 11_REG_010
  BL                  => 11_REG_011
  AH                  => 11_REG_100
  CH                  => 11_REG_101
  DH                  => 11_REG_110
  BH                  => 11_REG_111

  ---------------------------------------------------------------------------
  MOD 11 for 16-Bit Registers
  ---------------------------------------------------------------------------
  AX                  => 11_REG_000
  CX                  => 11_REG_001
  DX                  => 11_REG_010
  BX                  => 11_REG_011
  SP                  => 11_REG_100
  BP                  => 11_REG_101
  SI                  => 11_REG_110
  DI                  => 11_REG_111
                                        --

                        17) x86 Condition Test Encoding

  This section based on Table B-10 Condition Test (tttn) Field
    from the Intel 64 and IA-32 Architectures Software Developer's Manual

    O (Overflow)                     => 0000
   NO (No overflow)                  => 0001
    B (Below)                        => 0010
  NAE (Not above or equal)           => B
   NB (Not below)                    => 0011
   AE (Above or equal)               => NB
    E (Equal)                        => 0100
    Z (Zero)                         => E
   NE (Not equal)                    => 0101
   NZ (Not zero)                     => NE
   BE (Below or equal)               => 0110
   NA (Not above)                    => BE
  NBE (Not below or equal)           => 0111
    A (Above)                        => NBE
    S (Sign)                         => 1000
   NS (Not sign)                     => 1001
    P (Parity)                       => 1010
   PE (Parity even)                  => P
   NP (Not parity)                   => 1011
   PO (Parity odd)                   => NP
    L (Less than)                    => 1100
  NGE (Not greater than or equal to) => L
   NL (Not less than)                => 1101
   GE (Greater than or equal to)     => NL
   LE (Less than or equal to)        => 1110
   NG (Not greater than)             => LE
  NLE (Not less than or equal to)    => 1111
    G (Greater than)                 => NLE
                                        --

                  18) x86 Instruction Encodings for x86GenXYZ

  Instruction encodings based on Section B.2 General-Purpose Instruction
    Formats and Encodings For Non-64-Bit Modes.

                                [ ] = Untested
                                [^] = Partially Tested
                                [*] = Tested

  ---------------------------------------------------------------------------
  x86GenOp
  ---------------------------------------------------------------------------
  [*] cbw                        => 1001_1000
  [*] cwd                        => 1001_1001
  [*] clc                        => 1111_1000
  [*] cld                        => 1111_1100
  [*] cli                        => 1111_1010
  [*] cmc                        => 1111_0101
  [*] int3                       => 1100_1100
  [*] iret                       => 1100_1111
  [*] lahf                       => 1001_1111
  [*] nop                        => 1001_0000
  [*] pushf                      => 1001_1100
  [*] popf                       => 1001_1101
  [*] ret                        => 1100_0011
  [*] retf                       => 1100_1011
  [*] sahf                       => 1001_1110
  [*] stc                        => 1111_1001
  [*] std                        => 1111_1101
  [*] sti                        => 1111_1011
  [*] xlat                       => 1101_0111
  [*] xlatb                      => 1101_0111

  ---------------------------------------------------------------------------
  x86GenRepOp
  ---------------------------------------------------------------------------
  [*] rep lodsb                  => 1111_0011, 1010_1100
  [*] rep lodsw                  => 1111_0011, 1010_1101
  [*] rep movsb                  => 1111_0011, 1010_0100
  [*] rep movsw                  => 1111_0011, 1010_0101
  [*] rep stosb                  => 1111_0011, 1010_1010
  [*] rep stosw                  => 1111_0011, 1010_1011
  [*] repe cmpsb                 => 1111_0011, 1010_0110
  [*] repe cmpsw                 => 1111_0011, 1010_0111
  [*] repe scasb                 => 1111_0011, 1010_1110
  [*] repe scasb                 => 1111_0011, 1010_1111
  [*] repne cmpsb                => 1111_0010, 1010_0110
  [*] repne cmpsw                => 1111_0010, 1010_0111
  [*] repne scasb                => 1111_0010, 1010_1110
  [*] repne scasw                => 1111_0010, 1010_1111
  [*] repz cmpsb                 => 1111_0011, 1010_0110
  [*] repz cmpsw                 => 1111_0011, 1010_0111
  [*] repz scasb                 => 1111_0011, 1010_1110
  [*] repz scasb                 => 1111_0011, 1010_1111
  [*] repnz cmpsb                => 1111_0010, 1010_0110
  [*] repnz cmpsw                => 1111_0010, 1010_0111
  [*] repnz scasb                => 1111_0010, 1010_1110
  [*] repnz scasw                => 1111_0010, 1010_1111

  ---------------------------------------------------------------------------
  x86GenOpImm
  ---------------------------------------------------------------------------
  [*] int UINT8                  => 1100_1101, UINT8
  [*] jb [short] INT8            => 0111_0010, INT8
  [*] jb [near] INT16            => 0000_1111, 1000_0010, INT16
  [*] jc [short] INT8            => jb
  [*] jc [near] INT16            => jb
  [*] jae [short] INT8           => 0111_0011, INT8
  [*] jae [near] INT16           => 0000_1111, 1000_0011, INT16
  [*] jnc [short] INT8           => jae
  [*] jnc [near] INT16           => jae
  [*] je [short] INT8            => 0111_0100, INT8
  [*] je [near] INT16            => 0000_1111, 1000_0100, INT16
  [*] jz [short] INT8            => je
  [*] jz [near] INT16            => je
  [*] jne [short] INT8           => 0111_0101, INT8
  [*] jne [near] INT16           => 0000_1111, 1000_0101, INT16
  [*] jnz [short] INT8           => jne
  [*] jnz [near] INT16           => jne
  [*] jbe [short] INT8           => 0111_0110, INT8
  [*] jbe [near] INT16           => 0000_1111, 1000_0110, INT16
  [*] ja [short] INT8            => 0111_0111, INT8
  [*] ja [near] INT16            => 0000_1111, 1000_0111, INT16
  [*] js [short] INT8            => 0111_1000, INT8
  [*] js [near] INT16            => 0000_1111, 1000_1000, INT16
  [*] jns [short] INT8           => 0111_1001, INT8
  [*] jns [near] INT16           => 0000_1111, 1000_1001, INT16
  [*] jl [short] INT8            => 0111_1100, INT8
  [*] jl [near] INT16            => 0000_1111, 1000_1100, INT16
  [*] jge [short] INT8           => 0111_1101, INT8
  [*] jge [near] INT16           => 0000_1111, 1000_1101, INT16
  [*] jle [short] INT8           => 0111_1110, INT8
  [*] jle [near] INT16           => 0000_1111, 1000_1110, INT16
  [*] jg [short] INT8            => 0111_1111, INT8
  [*] jg [near] INT16            => 0000_1111, 1000_1111, INT16
  [*] call [near] INT16          => 1110_1000, INT16
  [*] jcxz INT8                  => 1110_0011, INT8
  [*] jmp [short] INT8           => 1110_1011, INT8
  [*] jmp [near] INT16           => 1110_1001, INT16
  [*] loop INT8                  => 1110_0010, INT8
  [*] loope INT8                 => 1110_0001, INT8
  [*] loopz INT8                 => 1110_0001, INT8
  [*] loopne INT8                => 1110_0000, INT8
  [*] loopnz INT8                => 1110_0000, INT8
  [*] push INT8                  => 0110_1010, INT8
  [*] push UINT16                => 0110_1000, UINT16
  [*] ret UINT16                 => 1100_0010, UINT16
  [*] retf UINT16                => 1100_1010, UINT16

  ---------------------------------------------------------------------------
  x86GenOpSelOfs
  ---------------------------------------------------------------------------
  [*] call SEL16':'OFS16         => 1001_1010, OFS16, SEL16
  [*] jmp SEL16':'OFS16          => 1110_1010, OFS16, SEL16

  ---------------------------------------------------------------------------
  x86GenOpReg
  ---------------------------------------------------------------------------
  [*] not REG8                   => 1111_0110, 11_010_REG8
  [*] not REG16                  => 1111_0111, 11_010_REG16
  [^] call REG16                 => 1111_1111, 11_010_REG16
  [^] dec REG8                   => 1111_1110, 11_001_REG8
  [^] dec REG16                  => 1111_1111, 11_001_REG16
  [^] div REG8                   => 1111_0110, 11_110_REG8
  [^] div REG16                  => 1111_0111, 11_110_REG16
  [^] idiv REG8                  => 1111_0110, 11_111_REG8
  [^] idiv REG16                 => 1111_0111, 11_111_REG16
  [^] imul REG8                  => 1111_0110, 11_101_REG8
  [^] imul REG16                 => 1111_0111, 11_101_REG16
  [^] inc REG8                   => 1111_1110, 11_000_REG8
  [^] inc REG16                  => 1111_1111, 11_000_REG16
  [^] mul REG8                   => 1111_0110, 11_100_REG8
  [^] mul REG16                  => 1111_0111, 11_100_REG16
  [^] jmp REG16                  => 1111_1111, 11_100_REG16
  [^] neg REG8                   => 1111_0110, 11_011_REG8
  [^] neg REG16                  => 1111_0111, 11_011_REG16
  [^] pop REG16                  => 0101_1_REG16
  [^] pop SREG                   => 000_SREG_111
  [^] push REG16                 => 0101_0_REG16
  [^] push SREG                  => 000_SREG_110

  ---------------------------------------------------------------------------
  x86GenOpMem
  ---------------------------------------------------------------------------
  [*] not MEM8                   => 1111_0110, MOD_010_MEM8[, <DISP8 | DISP16>]
  [*] not MEM16                  => 1111_0111, MOD_010_MEM16[, <DISP8 | DISP16>]
  [^] call [near] MEM16          => 1111_1111, MOD_010_MEM16[, <DISP8 | DISP16>]
  [^] call MEMSELOFS             => 1111_1111, MOD_011_MEMSELOFS[, <DISP8 | DISP16>]
  [^] jmp [near] MEM16           => 1111_1111, MOD_100_MEM16[, <DISP8 | DISP16>]
  [^] jmp MEMSELOFS              => 1111_1111, MOD_101_MEMSELOFS[, <DISP8 | DISP16>]
  [^] dec MEM8                   => 1111_1110, MOD_001_MEM8[, <DISP8 | DISP16>]
  [^] dec MEM16                  => 1111_1111, MOD_001_MEM16[, <DISP8 | DISP16>]
  [^] div MEM8                   => 1111_0110, MOD_110_MEM8[, <DISP8 | DISP16>]
  [^] div MEM16                  => 1111_0111, MOD_110_MEM16[, <DISP8 | DISP16>]
  [^] idiv MEM8                  => 1111_0110, MOD_111_MEM8[, <DISP8 | DISP16>]
  [^] idiv MEM16                 => 1111_0111, MOD_111_MEM16[, <DISP8 | DISP16>]
  [^] imul MEM8                  => 1111_0110, MOD_101_REG8
  [^] imul MEM16                 => 1111_0111, MOD_101_REG16
  [^] inc MEM8                   => 1111_1110, MOD_000_MEM8[, <DISP8 | DISP16>]
  [^] inc MEM16                  => 1111_1111, MOD_000_MEM16[, <DISP8 | DISP16>]
  [^] mul MEM8                   => 1111_0110, MOD_100_MEM8[, <DISP8 | DISP16>]
  [^] mul MEM16                  => 1111_0111, MOD_100_MEM16[, <DISP8 | DISP16>]
  [^] neg MEM8                   => 1111_0110, MOD_011_MEM8[, <DISP8 | DISP16>]
  [^] neg MEM16                  => 1111_0111, MOD_011_MEM16[, <DISP8 | DISP16>]
  [^] pop MEM16                  => 1000_1111, MOD_000_MEM16[, <DISP8 | DISP16>]
  [^] push MEM16                 => 1111_1111, MOD_110_MEM16

  ---------------------------------------------------------------------------
  x86GenOpRegImm
  ---------------------------------------------------------------------------
  [*] mov REG8',' UINT8          => 1100_0110, 11_000_REG8, UINT8
  [*] mov REG16',' UINT16        => 1100_0111, 11_000_REG16, UINT16
  [ ] adc REG8',' UINT8          => 1000_0000, 11_010_REG8, UINT8
  [ ] adc REG8',' INT8           => 1000_0010, 11_010_REG8, INT8
  [ ] adc REG16',' UINT16        => 1000_0001, 11_010_REG16, UINT16
  [ ] add REG8',' UINT8          => 1000_0000, 11_000_REG8, UINT8
  [ ] add REG8',' INT8           => 1000_0010, 11_000_REG8, INT8
  [ ] add REG16',' UINT16        => 1000_0001, 11_000_REG16, UINT16
  [ ] and REG8',' UINT8          => 1000_0000, 11_100_REG8, UINT8
  [ ] and REG8',' INT8           => 1000_0010, 11_100_REG8, INT8
  [ ] and REG16',' UINT16        => 1000_0001, 11_100_REG16, UINT16
  [ ] cmp REG8',' UINT8          => 1000_0000, 11_111_REG8, UINT8
  [ ] cmp REG8',' INT8           => 1000_0010, 11_111_REG8, INT8
  [ ] cmp REG16',' UINT16        => 1000_0001, 11_111_REG16, UINT16
  [ ] in al',' UINT8             => 1110_0100, UINT8
  [ ] in ax',' UINT8             => 1110_0101, UINT8
  [ ] or REG8',' UINT8           => 1000_0000, 11_001_REG8, UINT8
  [ ] or REG8',' INT8            => 1000_0010, 11_001_REG8, INT8
  [ ] or REG16',' UINT16         => 1000_0001, 11_001_REG16, UINT16
  [ ] out al',' UINT8            => 1110_0110, UINT8
  [ ] out ax',' UINT8            => 1110_0111, UINT8
  [ ] rcl REG8',' UINT8          => 1100_0000, 11_010_REG8, UINT8
  [ ] rcl REG16',' UINT8         => 1100_0001, 11_010_REG16, UINT8
  [ ] rcr REG8',' UINT8          => 1100_0000, 11_011_REG8, UINT8
  [ ] rcr REG16',' UINT8         => 1100_0001, 11_011_REG16, UINT8
  [ ] rol REG8',' UINT8          => 1100_0000, 11_000_REG8, UINT8
  [ ] rol REG16',' UINT8         => 1100_0001, 11_000_REG16, UINT8
  [ ] ror REG8',' UINT8          => 1100_0000, 11_001_REG8, UINT8
  [ ] ror REG16',' UINT8         => 1100_0001, 11_001_REG16, UINT8
  [ ] sar REG8',' UINT8          => 1100_0000, 11_111_REG8, UINT8
  [ ] sar REG16',' UINT8         => 1100_0001, 11_111_REG16, UINT8
  [ ] sbb REG8',' UINT8          => 1000_0000, 11_011_REG8, UINT8
  [ ] sbb REG8',' INT8           => 1000_0010, 11_011_REG8, INT8
  [ ] sbb REG16',' UINT16        => 1000_0001, 11_011_REG16, UINT16
  [ ] shl REG8',' UINT8          => 1100_0000, 11_100_REG8, UINT8
  [ ] shl REG16',' UINT8         => 1100_0001, 11_100_REG16, UINT8
  [ ] sal                        => shl
  [ ] shr REG8',' UINT8          => 1100_0000, 11_101_REG8, UINT8
  [ ] shr REG16',' UINT8         => 1100_0001, 11_101_REG16, UINT8
  [ ] sub REG8',' UINT8          => 1000_0000, 11_101_REG8, UINT8
  [ ] sub REG8',' INT8           => 1000_0010, 11_101_REG8, INT8
  [ ] sub REG16',' UINT16        => 1000_0001, 11_101_REG16, UINT16
  [ ] test REG8',' UINT8         => 1111_0110, 11_000_REG8
  [ ] test REG16',' UINT16       => 1111_0111, 11_000_REG16
  [ ] xor REG8',' UINT8          => 1000_0000, 11_110_REG8, UINT8
  [ ] xor REG8',' INT8           => 1000_0010, 11_110_REG8, INT8
  [ ] xor REG16',' UINT16        => 1000_0001, 11_110_REG16, UINT16

  ---------------------------------------------------------------------------
  x86GenOpRegReg
  ---------------------------------------------------------------------------
  [*] adc DESTREG8',' SRCREG8    => 0001_0000, 11_SRCREG8_DESTREG8
  [*] adc DESTREG16',' SRCREG16  => 0001_0001, 11_SRCREG16_DESTREG16
  [ ] add DESTREG8',' SRCREG8    => 0000_0000, 11_SRCREG8_DESTREG8
  [ ] add DESTREG16',' SRCREG16  => 0000_0001, 11_SRCREG16_DESTREG16
  [ ] and DESTREG8',' SRCREG8    => 0010_0000, 11_SRCREG8_DESTREG8
  [ ] and DESTREG16',' SRCREG16  => 0010_0001, 11_SRCREG16_DESTREG16
  [ ] cmp DESTREG8',' SRCREG8    => 0011_1000, 11_SRCREG8_DESTREG8
  [ ] cmp DESTREG16',' SRCREG16  => 0011_1011, 11_SRCREG16_DESTREG16
  [ ] mov DESTREG8',' SRCREG8    => 1000_1000, 11_SRCREG8_DESTREG8
  [ ] mov DESTREG16',' SRCREG16  => 1000_1001, 11_SRCREG16_DESTREG16
  [ ] or DESTREG8',' SRCREG8     => 0000_1000, 11_SRCREG8_DESTREG8
  [ ] or DESTREG16',' SRCREG16   => 0000_1011, 11_SRCREG16_DESTREG16
  [ ] sbb DESTREG8',' SRCREG8    => 0001_1000, 11_SRCREG8_DESTREG8
  [ ] sbb DESTREG16',' SRCREG16  => 0001_1001, 11_SRCREG16_DESTREG16
  [ ] sub DESTREG8',' SRCREG8    => 0010_1000, 11_SRCREG8_DESTREG8
  [ ] sub DESTREG16',' SRCREG16  => 0010_1001, 11_SRCREG16_DESTREG16
  [ ] test DESTREG8',' SRCREG8   => 1000_0100, 11_SRCREG8_DESTREG8
  [ ] test DESTREG16',' SRCREG16 => 1000_0101, 11_SRCREG16_DESTREG16
  [ ] xchg DESTREG8',' SRCREG8   => 1000_0110, 11_SRCREG8_DESTREG8
  [ ] xchg DESTREG16',' SRCREG16 => 1000_0111, 11_SRCREG16_DESTREG16
  [ ] xor DESTREG8',' SRCREG8    => 0011_0000, 11_SRCREG8_DESTREG8
  [ ] xor DESTREG16',' SRCREG16  => 0011_0001, 11_SRCREG16_DESTREG16
  [ ] in al',' dx                => 1110_1100
  [ ] in ax',' dx                => 1110_1101
  [ ] mov SREG',' REG16          => 1000_1110, 11_SREG_REG16
  [ ] mov REG16',' SREG          => 1000_1100, 11_SREG_REG16
  [ ] out al',' dx               => 1110_1110
  [ ] out ax',' dx               => 1110_1111
  [ ] rcl REG8',' CL             => 1101_0010, 11_010_REG8
  [ ] rcl REG16',' CL            => 1101_0011, 11_010_REG16
  [ ] rcr REG8',' CL             => 1101_0010, 11_011_REG8
  [ ] rcr REG16',' CL            => 1101_0011, 11_011_REG16
  [ ] rol REG8',' CL             => 1101_0010, 11_000_REG8
  [ ] rol REG16',' CL            => 1101_0011, 11_000_REG16
  [ ] ror REG8',' CL             => 1101_0010, 11_001_REG8
  [ ] ror REG16',' CL            => 1101_0011, 11_001_REG16
  [ ] sar REG8',' CL             => 1101_0010, 11_111_REG8
  [ ] sar REG16',' CL            => 1101_0011, 11_111_REG16
  [ ] shl REG8',' CL             => 1101_0010, 11_100_REG8
  [ ] shl REG16',' CL            => 1101_0011, 11_100_REG16
  [ ] sal                        => shl
  [ ] shr REG8',' CL             => 1101_0010, 11_101_REG8
  [ ] shr REG16',' CL            => 1101_0011, 11_101_REG16

  ---------------------------------------------------------------------------
  x86GenOpRegMem
  ---------------------------------------------------------------------------
  [*] mov REG8',' MEM8           => 1000_1010, MOD_REG8_MEM8[, <DISP8 | DISP16>]
  [*] mov REG16',' MEM16         => 1000_1011, MOD_REG16_MEM16[, <DISP8 | DISP16>]
  [^] adc REG8',' MEM8           => 0001_0010, MOD_REG8_MEM8[, <DISP8 | DISP16>]
  [^] adc REG16',' MEM16         => 0001_0011, MOD_REG16_MEM16[, <DISP8 | DISP16>]
  [^] add REG8',' MEM8           => 0000_0010, MOD_REG8_MEM8[, <DISP8 | DISP16>]
  [^] add REG16',' MEM16         => 0000_0011, MOD_REG16_MEM16[, <DISP8 | DISP16>]
  [^] and REG8',' MEM8           => 0010_0010, MOD_REG8_MEM8[, <DISP8 | DISP16>]
  [^] and REG16',' MEM16         => 0010_0011, MOD_REG16_MEM16[, <DISP8 | DISP16>]
  [^] cmp REG8',' MEM8           => 0011_1000, MOD_REG8_MEM8[, <DISP8 | DISP16>]
  [^] cmp REG16',' MEM16         => 0011_1001, MOD_REG16_MEM16[, <DISP8 | DISP16>]
  [^] or REG8',' MEM8            => 0000_1010, MOD_REG8_MEM8[, <DISP8 | DISP16>]
  [^] or REG16',' MEM16          => 0000_1011, MOD_REG16_MEM16[, <DISP8 | DISP16>]
  [^] sbb REG8',' MEM8           => 0001_1010, MOD_REG8_MEM8[, <DISP8 | DISP16>]
  [^] sbb REG16',' MEM16         => 0001_1011, MOD_REG16_MEM16[, <DISP8 | DISP16>]
  [^] sub REG8',' MEM8           => 0010_1010, MOD_REG8_MEM8[, <DISP8 | DISP16>]
  [^] sub REG16',' MEM16         => 0010_1011, MOD_REG16_MEM16[, <DISP8 | DISP16>]
  [^] test REG8',' MEM8          => 1000_0100, MOD_REG8_MEM8[, <DISP8 | DISP16>]
  [^] test REG16',' MEM16        => 1000_0101, MOD_REG8_MEM16[, <DISP8 | DISP16>]
  [^] xchg REG8',' MEM8          => 1000_0110, MOD_REG8_MEM8[, <DISP8 | DISP16>]
  [^] xchg REG16',' MEM16        => 1000_0111, MOD_REG16_MEM16[, <DISP8 | DISP16>]
  [^] xor REG8',' MEM8           => 0011_0010, MOD_REG8_MEM8[, <DISP8 | DISP16>]
  [^] xor REG16',' MEM16         => 0011_0011, MOD_REG16_MEM16[, <DISP8 | DISP16>]
  [^] mov SREG',' MEM16          => 1000_1110, MOD_SREG_MEM16[, <DISP8 | DISP16>]
  [^] lds REG16',' MEM32         => 1100_0101, MODab_REG16_MEM32
  [^] les REG16',' MEM32         => 1100_0100, MODab_REG16_MEM32
  [^] lea REG16',' MEM32         => 1000_1101, MODa_REG16_MEM32

  ---------------------------------------------------------------------------
  x86GenOpMemImm
  ---------------------------------------------------------------------------
  [*] mov MEM8',' UINT8          => 1100_0110, MOD_000_MEM8[, <DISP8 | DISP16>], UINT8
  [*] mov MEM16',' UINT16        => 1100_0111, MOD_000_MEM16[, <DISP8 | DISP16>], UINT16
  [ ] adc MEM8',' UINT8          => 1000_0000, MOD_010_MEM8[, <DISP8 | DISP16>], UINT8
  [ ] adc MEM8',' INT8           => 1000_0010, MOD_010_MEM8[, <DISP8 | DISP16>], INT8
  [ ] adc MEM16',' UINT16        => 1000_0001, MOD_010_MEM16[, <DISP8 | DISP16>], UINT16
  [ ] add MEM8',' UINT8          => 1000_0000, MOD_000_MEM8[, <DISP8 | DISP16>], UINT8
  [ ] add MEM8',' INT8           => 1000_0010, MOD_000_MEM8[, <DISP8 | DISP16>], INT8
  [ ] add MEM16',' UINT16        => 1000_0001, MOD_000_MEM16[, <DISP8 | DISP16>], UINT16
  [ ] and MEM8',' UINT8          => 1000_0000, MOD_100_MEM8[, <DISP8 | DISP16>], UINT8
  [ ] and MEM8',' INT8           => 1000_0010, MOD_100_MEM8[, <DISP8 | DISP16>], INT8
  [ ] and MEM16',' UINT16        => 1000_0001, MOD_100_MEM16[, <DISP8 | DISP16>], UINT16
  [ ] cmp MEM8',' UINT8          => 1000_0000, MOD_111_MEM8[, <DISP8 | DISP16>], UINT8
  [ ] cmp MEM8',' INT8           => 1000_0010, MOD_111_MEM8[, <DISP8 | DISP16>], INT8
  [ ] cmp MEM16',' UINT16        => 1000_0001, MOD_111_MEM16[, <DISP8 | DISP16>], UINT16
  [ ] or MEM8',' UINT8           => 1000_0000, MOD_001_MEM8[, <DISP8 | DISP16>], UINT8
  [ ] or MEM8',' INT8            => 1000_0010, MOD_001_MEM8[, <DISP8 | DISP16>], INT8
  [ ] or MEM16',' UINT16         => 1000_0001, MOD_001_MEM16[, <DISP8 | DISP16>], UINT16
  [ ] rcl MEM8',' UINT8          => 1100_0000, MOD_010_MEM8[, <DISP8 | DISP16>], UINT8
  [ ] rcl MEM16',' UINT8         => 1100_0001, MOD_010_MEM16[, <DISP8 | DISP16>], UINT8
  [ ] rcr MEM8',' UINT8          => 1100_0000, MOD_011_MEM8[, <DISP8 | DISP16>], UINT8
  [ ] rcr MEM16',' UINT8         => 1100_0001, MOD_011_MEM16[, <DISP8 | DISP16>], UINT8
  [ ] rol MEM8',' UINT8          => 1100_0000, MOD_000_MEM8[, <DISP8 | DISP16>], UINT8
  [ ] rol MEM16',' UINT8         => 1100_0001, MOD_000_MEM16[, <DISP8 | DISP16>], UINT8
  [ ] ror MEM8',' UINT8          => 1100_0000, MOD_001_MEM8[, <DISP8 | DISP16>], UINT8
  [ ] ror MEM16',' UINT8         => 1100_0001, MOD_001_MEM16[, <DISP8 | DISP16>], UINT8
  [ ] sar MEM8',' UINT8          => 1100_0000, MOD_111_MEM8[, <DISP8 | DISP16>], UINT8
  [ ] sar MEM16',' UINT8         => 1100_0001, MOD_111_MEM16[, <DISP8 | DISP16>], UINT8
  [ ] sbb MEM8',' UINT8          => 1000_0000, MOD_011_MEM8[, <DISP8 | DISP16>], UINT8
  [ ] sbb MEM8',' INT8           => 1000_0010, MOD_011_MEM8[, <DISP8 | DISP16>], INT8
  [ ] sbb MEM16',' UINT16        => 1000_0001, MOD_011_MEM16[, <DISP8 | DISP16>], UINT16
  [ ] shl MEM8',' UINT8          => 1100_0000, MOD_100_MEM8[, <DISP8 | DISP16>], UINT8
  [ ] shl MEM16',' UINT8         => 1100_0001, MOD_100_MEM16[, <DISP8 | DISP16>], UINT8
  [ ] sal                        => shl
  [ ] shr MEM8',' UINT8          => 1100_0000, MOD_101_MEM8[, <DISP8 | DISP16>], UINT8
  [ ] shr MEM16',' UINT8         => 1100_0001, MOD_101_MEM16[, <DISP8 | DISP16>], UINT8
  [ ] sub MEM8',' UINT8          => 1000_0000, MOD_101_MEM8[, <DISP8 | DISP16>], UINT8
  [ ] sub MEM8',' INT8           => 1000_0010, MOD_101_MEM8[, <DISP8 | DISP16>], INT8
  [ ] sub MEM16',' UINT16        => 1000_0001, MOD_101_MEM16[, <DISP8 | DISP16>], UINT16
  [ ] test MEM8',' UINT8         => 1111_0110, MOD_000_MEM8[, <DISP8 | DISP16>], UINT8
  [ ] test MEM16',' UINT16       => 1111_0111, MOD_000_MEM8[, <DISP8 | DISP16>], UINT16
  [ ] xor MEM8',' UINT8          => 1000_0000, MOD_110_MEM8[, <DISP8 | DISP16>], UINT8
  [ ] xor MEM8',' INT8           => 1000_0010, MOD_110_MEM8[, <DISP8 | DISP16>], INT8
  [ ] xor MEM16',' UINT16        => 1000_0001, MOD_110_MEM16[, <DISP8 | DISP16>], UINT16

  ---------------------------------------------------------------------------
  x86GenOpMemReg
  ---------------------------------------------------------------------------
  [*] mov MEM8',' REG8           => 1000_1000, MOD_REG8_MEM8[, <DISP8 | DISP16>]
  [*] mov MEM16',' REG16         => 1000_1001, MOD_REG16_MEM16[, <DISP8 | DISP16>]
  [^] adc MEM8',' REG8           => 0001_0000, MOD_REG8_MEM8[, <DISP8 | DISP16>]
  [^] adc MEM16',' REG16         => 0001_0001, MOD_REG16_MEM16[, <DISP8 | DISP16>]
  [^] add MEM8',' REG8           => 0000_0000, MOD_REG8_MEM8[, <DISP8 | DISP16>]
  [^] add MEM16',' REG16         => 0000_0001, MOD_REG16_MEM16[, <DISP8 | DISP16>]
  [^] and MEM8',' REG8           => 0010_0000, MOD_REG8_MEM8[, <DISP8 | DISP16>]
  [^] and MEM16',' REG16         => 0010_0001, MOD_REG16_MEM16[, <DISP8 | DISP16>]
  [^] cmp MEM8',' REG8           => 0011_1010, MOD_REG8_MEM8[, <DISP8 | DISP16>]
  [^] cmp MEM16',' REG16         => 0011_1011, MOD_REG16_MEM16[, <DISP8 | DISP16>]
  [^] or MEM8',' REG8            => 0000_1000, MOD_REG8_MEM8[, <DISP8 | DISP16>]
  [^] or MEM16',' REG16          => 0000_1001, MOD_REG16_MEM16[, <DISP8 | DISP16>]
  [^] sbb MEM8',' REG8           => 0001_1000, MOD_REG8_MEM8[, <DISP8 | DISP16>]
  [^] sbb MEM16',' REG16         => 0001_1001, MOD_REG16_MEM16[, <DISP8 | DISP16>]
  [^] sub MEM8',' REG8           => 0010_1000, MOD_REG8_MEM8[, <DISP8 | DISP16>]
  [^] sub MEM16',' REG16         => 0010_1001, MOD_REG16_MEM16[, <DISP8 | DISP16>]
  [^] xor MEM8',' REG8           => 0011_0000, MOD_REG8_MEM8[, <DISP8 | DISP16>]
  [^] xor MEM16',' REG16         => 0011_0001, MOD_REG16_MEM16[, <DISP8 | DISP16>]
  [^] mov MEM16',' SREG          => 1000_1100, MOD_SREG_MEM16[, <DISP8 | DISP16>]

  ---------------------------------------------------------------------------
  x86GenOpMemCL
  ---------------------------------------------------------------------------
  [^] rcl MEM8',' CL             => 1101_0010, MOD_010_MEM8[, <DISP8 | DISP16>]
  [^] rcl MEM16',' CL            => 1101_0011, MOD_010_MEM16[, <DISP8 | DISP16>]
  [^] rcr MEM8',' CL             => 1101_0010, MOD_011_MEM8[, <DISP8 | DISP16>]
  [^] rcr MEM16',' CL            => 1101_0011, MOD_011_MEM16[, <DISP8 | DISP16>]
  [^] rol MEM8',' CL             => 1101_0010, MOD_000_MEM8[, <DISP8 | DISP16>]
  [^] rol MEM16',' CL            => 1101_0011, MOD_000_MEM16[, <DISP8 | DISP16>]
  [^] ror MEM8',' CL             => 1101_0010, MOD_001_MEM8[, <DISP8 | DISP16>]
  [^] ror MEM16',' CL            => 1101_0011, MOD_001_MEM16[, <DISP8 | DISP16>]
  [^] sar MEM8',' CL             => 1101_0010, MOD_111_MEM8[, <DISP8 | DISP16>]
  [^] sar MEM16',' CL            => 1101_0011, MOD_111_MEM16[, <DISP8 | DISP16>]
  [^] shl MEM8',' CL             => 1101_0010, MOD_100_MEM8[, <DISP8 | DISP16>]
  [^] shl MEM16',' CL            => 1101_0011, MOD_100_MEM16[, <DISP8 | DISP16>]
  [^] sal                        => shl
  [^] shr MEM8',' CL             => 1101_0010, MOD_101_MEM8[, <DISP8 | DISP16>]
  [^] shr MEM16',' CL            => 1101_0011, MOD_101_MEM16[, <DISP8 | DISP16>]
