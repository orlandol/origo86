

                   Origo86 Language Specification
                   Copyright 2018 Orlando Llanes


                        Table of Contents

                        1) Introduction
                        2) Symbol Reference
                        3) Program Structure
                        4) Module Structure
                        5) Type Specification
                        6) General Declarations
                        7) Object Declarations
                        8) Method Declarations
                        9) Function Declarations
                       10) Operator Declarations
                       11) General Statements
                       12) Conditional Statements
                       13) Loop Statements
                       14) Assembler Statements
                                      --

                          1) Introduction

  The purpose of this document is to define the syntax structure of
    Origo86; similar in concept to an informal grammar specification.

  Retineo is Latin for steadfast. Origo is Latin for origin.

  Retineo is a general programming language designed to provide
    a stable foundation for low level, and cross-platform,
    software development.

  Low level syntax across platforms share a common structure,
    adapting unique platform specific constructs where needed.

  High level syntax allows the developer to declare a common interface
    once, while hiding platform specifics in the implementation.

  Retineo's syntax began with a Pascal, Basic, and C++ influence.
    Its syntax evolved to be simple and unambiguous, allowing the
    developer to maintain their stream of consciousness.

  Retineo's launch occurs in three phases:
    A) Origo86 - One-time x86 assembler implementation, to launch Origo.
    B) Origo - Self-compiling subset, to launch Retineo.
    C) Retineo - Self-compiling, full language implementation, of Retineo.

  This specification will likely change until Origo86 is complete.
                                      --

                         2) Symbol Reference

  2A) X => Y

    X becomes Y. Used to indicate how it will be referred to.

  2B) [ ]

    Everything enclosed within the brackets is optional. Brackets
    may be nested.

  2C) < | >

    Only one of the specified keywords/syntax applies per use.

  2D) ' '

    Syntax used as-is in source code text.
    Differentiates between convention symbol, and actual source code text.

  2E) ...

    Represents that preceding syntax may be repeated.
                                      --

                        3) Program Structure

  // Single line comment

  /* Multi-line
    /* and nested multi-line */
    comments */

  program IDENT => PROGNAME

  [uses MODNAME['(' FILENAME ')'][',' ...]]

  [DECLARATION]
  [...]

  run
    [var
      [TYPESPEC IDENT[','...]]
      [...]
    end]

    [STATEMENT]
    [...]
  end

  [DECLARATION]
  [...]
                                      --

                            4) Module Structure

  // Single line comment

  /* Multi-line
    /* and nested multi-line */
    comments */

  module IDENT => MODNAME

  [uses MODNAME['(' FILENAME ')'][',' ...]]

  [DECLARATION]
  [...]

  implementation

  [uses MODNAME['(' FILENAME ')'][',' ...]]

  [DECLARATION]
  [...]

  init
    [var
      [TYPESPEC IDENT[','...]]
      [...]
    end]

    [STATEMENT]
    [...]
  end

  done
    [var
      [TYPESPEC IDENT[','...]]
      [...]
    end]

    [STATEMENT]
    [...]
  end

  [DECLARATION]
  [...]
                                      --

                        5) Type Specification

  BASETYPE = < uint | uint8 | uint16 | int | int8 | int16 |
               bool | char  | string >
             
  SIMPLETYPE = < BASETYPE | TYPENAME | STRUCTNAME | UNIONNAME |
                 OBJNAME['('IFCNAME[','...]')'] |
                 ABSNAME['('IFCNAME[','...]')'] >

  TYPESPEC = ['@']SIMPLETYPE[ '[' CONSTEXPR['..'CONSTEXPR][','...] ']' ]

    '@' specifies that the type is a pointer.
    Array indices can consist of either a range, or a count value.
                                      --

                            6) General Declarations

  type TYPESPEC IDENT[','...] ['=' CONSTEXPR] => TYPENAME

  alias TYPENAME IDENT => TYPENAME

  enum [BASETYPE] IDENT => ENUMNAME
    [group CONSTEXPR]
      [IDENT[','...] '=' CONSTEXPR] => ENUMVALUE
      [...]
    [...]
  end

  const [TYPESPEC] IDENT[','...] '=' < CONSTEXPR | INITIALIZER >

  struct IDENT => STRUCTNAME
    [TYPESPEC IDENT[','...]] => FIELDNAME
    [...]
  end

  union IDENT => STRUCTNAME
    [TYPESPEC IDENT[','...]] => FIELDNAME
    [...]
  end

  var
    [TYPESPEC IDENT[','...]['=' CONSTEXPR]] => GLOBALVAR
    [...]
  end

  funcdecl [TYPESPEC] IDENT '(' [PARAMDECL] ')'
    [link MANGLEDNAME from < OBJFILENAME | LIBFILENAME >
      [using CALLCONVENTION]]

  vardecl TYPESPEC IDENT
    [link MANGLEDNAME from < OBJFILENAME | LIBFILENAME >]
                                      --

                        7) Object Declarations

  object IDENT => OBJNAME [inherits OBJNAME[','...]]
  [ < public | visible | internal > ]
    [TYPESPEC IDENT[','...]] => MBRNAME
    [...]
  [...]
  end

  interface IDENT => IFCNAME
    [implements OBJNAME[','...]]
    [inherits IFCNAME[','...]]

    [method [TYPESPEC] [interrupt] IDENT] => MTHDNAME
    [...]
  end

  abstract IDENT => ABSNAME
    [implements OBJNAME[','...]]
    [inherits IFCNAME[','...]]

    [method [TYPESPEC] [interrupt] IDENT] => MTHDNAME
    [...]
  end

  private OBJNAME
    [TYPESPEC IDENT[','...]] => MBRNAME
    [...]
  end

  private IFCNAME
    [method [TYPESPEC] IDENT '(' [PARAMDECL] ')'] => MTHDNAME
    [...]
  end

  private ABSNAME
    [method [TYPESPEC] IDENT '(' [PARAMDECL] ')'] => MTHDNAME
    [...]
  end
                                      --

                        8) Method Declarations

  method [interrupt] OBJNAME'.'MTHDNAME '(' [PARAMDECL] ')'
    [var
      [TYPESPEC IDENT[','...]['=' CONSTEXPR]] => LOCALVAR
      [...]
    end]

    < [STATEMENT] | [return] >
    [...]
  end

  method TYPESPEC [interrupt] OBJNAME'.'MTHDNAME '(' [PARAMDECL] ')'
    [var
      [TYPESPEC IDENT[','...]['=' CONSTEXPR]] => LOCALVAR
      [...]
    end]

    < [STATEMENT] |
    [result ASSIGNOP EXPR] |
    [return [EXPR]] >
    [...]
  end

  method [TYPESPEC] asm [< noret | noframe >] [interrupt]
    OBJNAME'.'MTHDNAME '(' [PARAMDECL] ')'

    [var
      [TYPESPEC IDENT[','...]] => LOCALVAR
      [...]
    end]

    [ASMSTATEMENT]
    [...]
  end
                                      --

                        9) Function Declarations

  func [interrupt] IDENT '(' [PARAMDECL] ')' => FUNCNAME
    [var
      [TYPESPEC IDENT[','...]['=' CONSTEXPR]] => LOCALVAR
      [...]
    end]

    < [STATEMENT] | [return] >
    [...]
  end

  func TYPESPEC [interrupt] IDENT '(' [PARAMDECL] ')' => FUNCNAME
    [var
      [TYPESPEC IDENT[','...]['=' CONSTEXPR]] => LOCALVAR
      [...]
    end]

    < [STATEMENT] |
    [result ASSIGNOP EXPR] |
    [return [EXPR]] >
    [...]
  end

  func [TYPESPEC] asm [< noret | noframe >] [interrupt]
    IDENT '(' [PARAMDECL] ')' => FUNCNAME

    [var
      [TYPESPEC IDENT[','...]] => LOCALVAR
      [...]
    end]

    [ASMSTATEMENT]
    [...]
  end
                                      --

                       10) Operator Declarations

  operator TYPESPEC OP '(' TYPESPEC IDENT[','...] ')'
    < [STATEMENT] |
    [result ASSIGNOP EXPR] >
    [...]
  end

  cast TYPESPEC from TYPESPEC
    < [STATEMENT] |
    [result ASSIGNOP EXPR] >
    [...]
  end
                                      --

                       11) General Statements

  IDENT ':' => LABELNAME

  goto LABELNAME

  exit [CONSTEXPR]

  FUNCTIONCALL

  METHODCALL

  bind '(' OBJECTVAR ',' < IFCNAME | ABSNAME >[','...] ')'

  EXPRESSION
                                      --

                       12) Conditional Statements

  if CONDITION
    then STATEMENT

  if CONDITION
    [thenif CONDITION]
    [...]

    [STATEMENT]
    [...]
  [elseif CONDITION
    [thenif CONDITION]
    [...]

    [STATEMENT]
    [...]]
  [else
    [STATEMENT]
    [...]]
  endif

  [LABEL] case EXPR
    [precase
      < [STATEMENT] | [return] >
      [...]]
    [postcase
      < [STATEMENT] | [return] >
      [...]]
    [of CONSTEXPR['..' CONSTEXPR]
      < [STATEMENT] |
      [nextcase [LABEL] |
      [exitcase [LABEL] >
      [...]]
    [in '[' CONSTEXPR['..' CONSTEXPR][','...] ']'
      < [STATEMENT] |
      [nextcase [LABEL] |
      [exitcase [LABEL] >
      [...]]
    [default
      < [STATEMENT] |
      [nextcase [LABEL] |
      [exitcase [LABEL] >
      [...]]
  endcase
                                      --

                       13) Loop Statements

  [LABEL] while CONDITION
    < [STATEMENT] |
    [next [LABEL]] |
    [stop [LABEL]] >
    [...]
  endwhile

  [LABEL] repeat
    < [STATEMENT] |
    [next [LABEL]] |
    [stop [LABEL]] >
    [...]
  when CONDITION

  [LABEL] for IDENT in '[' EXPR['..' EXPR][','...] ']'
    < [STATEMENT] |
    [next [LABEL]] |
    [stop [LABEL]] >
    [...]
  endfor

  [LABEL] for IDENT '=' EXPR < to | downto > EXPR
    < [STATEMENT] |
    [next [LABEL]] |
    [stop [LABEL]] >
    [...]
  endfor

  [STATEMENT] until CONDITION
                                      --

                       14) Assembler Statements

                            x86 Instructions

  adc           jb            lodsb         rcl           sti
  add           jbe           lodsw         rcr           stos
  and           ja            loop          rol           stosb
  call          jae           loope         ror           stosw
  cbw           je            loopne        rep           sub
  clc           jne           loopz         repe          test
  cld           jz            loopnz        repne         xchg
  cli           jnz           mov           repz          xlat
  cmc           jl            movs          repnz         xlatb
  cmp           jle           movsb         ret           xor
  cmps          jg            movsw         retf
  cmpsb         jge           mul           sahf
  cmpsw         jc            neg           sal
  cwd           jnc           nop           sar
  dec           jcxz          not           shl
  div           jecxz         or            shr
  idiv          jmp           out           sbb
  imul          lahf          pop           scas
  in            lds           popf          scasb
  inc           les           push          scasw
  int           lea           pushf         stc
  iret          lods          rcl           std
                                      --
