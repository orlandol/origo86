

                   Origo86 Language Specification
                   Copyright 2018 Orlando Llanes


                        Table of Contents

                        1) Introduction
                        2) Symbol Glossary
                        3) Program Structure
                        4) Module Structure
                        5) Type Specification
                        6) General Declarations
                        7) Object Declarations
                        8) Method Declarations
                        9) Function Declarations
                       10) Operator Declarations
                       11) Expression Operators by Precedence
                       12) General Statements
                       13) Conditional Statements
                       14) Loop Statements
                       15) Assembler Statements
                                      --

                          1) Introduction

  The purpose of this document is to define the syntax structure of
    Origo86; similar in concept to an informal grammar specification.

  Retineo is Latin for steadfast. Origo is Latin for origin.

  Retineo is a general programming language designed to provide
    a stable foundation for low level, and cross-platform,
    software development.

  Low level syntax across platforms share a common structure,
    adapting unique platform specific constructs where needed.

  High level syntax allows the developer to declare a common interface
    once, while hiding platform specifics in the implementation.

  Retineo's syntax began with a Pascal, Basic, and C++ influence.
    Its syntax evolved to be simple and unambiguous, allowing the
    developer to maintain their stream of consciousness.

  Retineo's launch occurs in three phases:
    A) Origo86 - One-time x86 assembler implementation, to launch Origo.
    B) Origo - Self-compiling subset, to launch Retineo.
    C) Retineo - Self-compiling, full language implementation, of Retineo.

  This specification will likely change until Origo86 is complete.
                                      --

                         2) Symbol Reference

  2A) X => Y

    X becomes Y. Used to indicate how it will be referred to.

  2B) [ ]

    Everything enclosed within the brackets is optional. Brackets
    may be nested.

  2C) < | >

    Only one of the specified keywords/syntax applies per use.

  2D) ' '

    Syntax used as-is in source code text.
    Differentiates between convention symbol, and actual source code text.

  2E) ...

    Represents that preceding syntax may be repeated.
                                      --

                        3) Program Structure

  // Single line comment

  /* Multi-line
    /* and nested multi-line */
    comments */

  program IDENT => PROGNAME

  [uses MODNAME['(' FILENAME ')'][',' ...]]

  [DECLARATION]
  [...]

  run
    [var
      [TYPESPEC IDENT[','...]]
      [...]
    end]

    [STATEMENT]
    [...]
  end

  [DECLARATION]
  [...]
                                      --

                            4) Module Structure

  // Single line comment

  /* Multi-line
    /* and nested multi-line */
    comments */

  module IDENT => MODNAME

  [uses MODNAME['(' FILENAME ')'][',' ...]]

  [DECLARATION]
  [...]

  implementation

  [uses MODNAME['(' FILENAME ')'][',' ...]]

  [DECLARATION]
  [...]

  init
    [var
      [TYPESPEC IDENT[','...]]
      [...]
    end]

    [STATEMENT]
    [...]
  end

  done
    [var
      [TYPESPEC IDENT[','...]]
      [...]
    end]

    [STATEMENT]
    [...]
  end

  [DECLARATION]
  [...]
                                      --

                        5) Type Specification

  BASETYPE = < uint | uint8 | uint16 | int | int8 | int16 |
               bool | char  | string >
             
  SIMPLETYPE = < BASETYPE | TYPENAME | STRUCTNAME | UNIONNAME |
                 OBJNAME['('IFCNAME[','...]')'] |
                 ABSNAME['('IFCNAME[','...]')'] >

  TYPESPEC = ['@']SIMPLETYPE[ '[' CONSTEXPR['..'CONSTEXPR][','...] ']' ]

    '@' specifies that the type is a pointer.
    Array indices can consist of either a range, or a count value.
                                      --

                            6) General Declarations

  type TYPESPEC IDENT[','...] ['=' CONSTEXPR] => TYPENAME

  alias TYPENAME IDENT => TYPENAME

  enum [BASETYPE] IDENT => ENUMNAME
    [group CONSTEXPR]
      [IDENT[','...] '=' CONSTEXPR] => ENUMVALUE
      [...]
    [...]
  end

  const [TYPESPEC] IDENT[','...] '=' < CONSTEXPR | INITIALIZER >

  struct IDENT => STRUCTNAME
    [TYPESPEC IDENT[','...]] => FIELDNAME
    [...]
  end

  union IDENT => STRUCTNAME
    [TYPESPEC IDENT[','...]] => FIELDNAME
    [...]
  end

  var
    [TYPESPEC IDENT[','...]['=' CONSTEXPR]] => GLOBALVAR
    [...]
  end

  funcdecl [TYPESPEC] IDENT '(' [PARAMDECL] ')'
    [link MANGLEDNAME from < OBJFILENAME | LIBFILENAME >
      [using CALLCONVENTION]]

  vardecl TYPESPEC IDENT
    [link MANGLEDNAME from < OBJFILENAME | LIBFILENAME >]
                                      --

                        7) Object Declarations

  object IDENT => OBJNAME [inherits OBJNAME[','...]]
  [ < public | visible | internal > ]
    [TYPESPEC IDENT[','...]] => MBRNAME
    [...]
  [...]
  end

  interface IDENT => IFCNAME
    [implements OBJNAME[','...]]
    [inherits IFCNAME[','...]]

    [method [TYPESPEC] [interrupt] IDENT] => MTHDNAME
    [...]
  end

  abstract IDENT => ABSNAME
    [implements OBJNAME[','...]]
    [inherits IFCNAME[','...]]

    [method [TYPESPEC] [interrupt] IDENT] => MTHDNAME
    [...]
  end

  private OBJNAME
    [TYPESPEC IDENT[','...]] => MBRNAME
    [...]
  end

  private IFCNAME
    [method [TYPESPEC] IDENT '(' [PARAMDECL] ')'] => MTHDNAME
    [...]
  end

  private ABSNAME
    [method [TYPESPEC] IDENT '(' [PARAMDECL] ')'] => MTHDNAME
    [...]
  end
                                      --

                        8) Method Declarations

  method [interrupt] OBJNAME'.'MTHDNAME '(' [PARAMDECL] ')'
    [var
      [TYPESPEC IDENT[','...]['=' CONSTEXPR]] => LOCALVAR
      [...]
    end]

    < [STATEMENT] | [return] >
    [...]
  end

  method TYPESPEC [interrupt] OBJNAME'.'MTHDNAME '(' [PARAMDECL] ')'
    [var
      [TYPESPEC IDENT[','...]['=' CONSTEXPR]] => LOCALVAR
      [...]
    end]

    < [STATEMENT] |
    [result ASSIGNOP EXPR] |
    [return [EXPR]] >
    [...]
  end

  method [TYPESPEC] asm [< noret | noframe >] [interrupt]
    OBJNAME'.'MTHDNAME '(' [PARAMDECL] ')'

    [var
      [TYPESPEC IDENT[','...]] => LOCALVAR
      [...]
    end]

    [ASMSTATEMENT]
    [...]
  end
                                      --

                        9) Function Declarations

  func [interrupt] IDENT '(' [PARAMDECL] ')' => FUNCNAME
    [var
      [TYPESPEC IDENT[','...]['=' CONSTEXPR]] => LOCALVAR
      [...]
    end]

    < [STATEMENT] | [return] >
    [...]
  end

  func TYPESPEC [interrupt] IDENT '(' [PARAMDECL] ')' => FUNCNAME
    [var
      [TYPESPEC IDENT[','...]['=' CONSTEXPR]] => LOCALVAR
      [...]
    end]

    < [STATEMENT] |
    [result ASSIGNOP EXPR] |
    [return [EXPR]] >
    [...]
  end

  func [TYPESPEC] asm [< noret | noframe >] [interrupt]
    IDENT '(' [PARAMDECL] ')' => FUNCNAME

    [var
      [TYPESPEC IDENT[','...]] => LOCALVAR
      [...]
    end]

    [ASMSTATEMENT]
    [...]
  end
                                      --

                       10) Operator Declarations

  operator TYPESPEC OP '(' TYPESPEC IDENT[','...] ')'
    < [STATEMENT] |
    [result ASSIGNOP EXPR] >
    [...]
  end

  cast TYPESPEC from TYPESPEC
    < [STATEMENT] |
    [result ASSIGNOP EXPR] >
    [...]
  end
                                      --

                       11) Expression Operators by Precedence

  VAROPERAND '++' => Post-Increment
  VAROPERAND '--' => Post Decrement

  '++' VAROPERAND => Pre-Increment
  '--' VAROPERAND => Pre-Decrement
  '-' OPERAND => Neg
  '!' OPERAND => Logical Not
  '~' OPERAND => Bitwise Complement

  OPERAND '*' OPERAND => Multiply
  OPERAND '/' OPERAND => Divide
  OPERAND '%' OPERAND => Modulus

  OPERAND '+' OPERAND => Add
  OPERAND '-' OPERAND => Sub

  OPERAND '<<' OPERAND => Shift-Left
  OPERAND '>>' OPERAND => Shift-Right
  OPERAND '->>' OPERAND => Signed Shift-Right
  OPERAND '<<<' OPERAND => Rotate Left
  OPERAND '<<<-' OPERAND => Signed Rotate Left
  OPERAND '>>>' OPERAND => Rotate Right
  OPERAND '->>>' OPERAND => Signed Rotate Right

  OPERAND '<' OPERAND => Less Than
  OPERAND '<=' OPERAND => Less Than or Equal To
  OPERAND '>' OPERAND => Greated Than
  OPERAND '>=' OPERAND => Greater Than or Equal To

  OPERAND '=' OPERAND => Equal To
  OPERAND '!=' OPERAND => Not Equal To

  OPERAND '&' OPERAND => Bitwise And

  OPERAND '^' OPERAND => Bitwise Exclusive Or

  OPERAND '|' OPERAND => Bitwise Or

  OPERAND '&&' OPERAND => Logical And

  OPERAND '||' OPERAND => Logical Or

  RESULT '=' EXPRESSION => Assign result from expression
  RESULT '+=' EXPRESSION => Add expression to the result
  RESULT '-=' EXPRESSION => Subtract expression from the result
  RESULT '*=' EXPRESSION => Multiply result by expression
  RESULT '/=' EXPRESSION => Divide result by expression
  RESULT '%=' EXPRESSION => Modulo result by expression
  RESULT '<<=' EXPRESSION => Shift result Left by expression
  RESULT '>>=' EXPRESSION => Shift result Right by expression
  RESULT '->>=' EXPRESSION => Signed Shift result Right by expression
  RESULT '<<<=' EXPRESSION => Rotate result Left by expression
  RESULT '<<<-=' EXPRESSION => Signed Rotate result Left by expression
  RESULT '>>>=' EXPRESSION => Rotate result Right by expression
  RESULT '->>>=' EXPRESSION => Signed Rotate result Right by expression
  RESULT '&=' EXPRESSION => Bitwise And result by expression
  RESULT '^=' EXPRESSION => Bitwise Xor result by expression
  RESULT '|=' EXPRESSION => Bitwise Or result by expression
                                      --

                       12) General Statements

  IDENT ':' => LABELNAME

  goto LABELNAME

  exit [CONSTEXPR]

  FUNCTIONCALL

  METHODCALL

  bind '(' OBJECTVAR ',' < IFCNAME | ABSNAME >[','...] ')'

  EXPRESSION
                                      --

                       13) Conditional Statements

  if CONDITION
    then STATEMENT

  if CONDITION
    [thenif CONDITION]
    [...]

    [STATEMENT]
    [...]
  [elseif CONDITION
    [thenif CONDITION]
    [...]

    [STATEMENT]
    [...]]
  [else
    [STATEMENT]
    [...]]
  endif

  [LABEL] case EXPR
    [precase
      < [STATEMENT] | [return] >
      [...]]
    [postcase
      < [STATEMENT] | [return] >
      [...]]
    [of CONSTEXPR['..' CONSTEXPR]
      < [STATEMENT] |
      [nextcase [LABEL] |
      [exitcase [LABEL] >
      [...]]
    [in '[' CONSTEXPR['..' CONSTEXPR][','...] ']'
      < [STATEMENT] |
      [nextcase [LABEL] |
      [exitcase [LABEL] >
      [...]]
    [default
      < [STATEMENT] |
      [nextcase [LABEL] |
      [exitcase [LABEL] >
      [...]]
  endcase
                                      --

                       14) Loop Statements

  [LABEL] while CONDITION
    < [STATEMENT] |
    [next [LABEL]] |
    [stop [LABEL]] >
    [...]
  endwhile

  [LABEL] repeat
    < [STATEMENT] |
    [next [LABEL]] |
    [stop [LABEL]] >
    [...]
  when CONDITION

  [LABEL] for IDENT in '[' EXPR['..' EXPR][','...] ']'
    < [STATEMENT] |
    [next [LABEL]] |
    [stop [LABEL]] >
    [...]
  endfor

  [LABEL] for IDENT '=' EXPR < to | downto > EXPR
    < [STATEMENT] |
    [next [LABEL]] |
    [stop [LABEL]] >
    [...]
  endfor

  [STATEMENT] until CONDITION
                                      --

                       15) Assembler Statements

                            x86 Instructions

  adc           jb            lodsb         rcr           stos
  add           jbe           lodsw         rol           stosb
  and           ja            loop          ror           stosw
  call          jae           loope         rep           sub
  cbw           je            loopne        repe          test
  clc           jne           loopz         repne         xchg
  cld           jz            loopnz        repz          xlat
  cli           jnz           mov           repnz         xlatb
  cmc           jl            movs          ret           xor
  cmp           jle           movsb         retf
  cmps          jg            movsw         sahf
  cmpsb         jge           mul           sal
  cmpsw         jc            neg           sar
  cwd           jnc           nop           shl
  dec           jcxz          not           shr
  div           jecxz         or            sbb
  idiv          jmp           out           scas
  imul          lahf          pop           scasb
  in            lds           popf          scasw
  inc           les           push          stc
  int           lea           pushf         std
  iret          lods          rcl           sti
                                      --
